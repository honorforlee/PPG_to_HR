%Name = '3900497mB';        % row 6
%Name = '3900679m';         % row 5
%Name = '3914288m';         % row 5
%Name = '3916979m (5)';     % row 6  (1 : 5)
%Name = '3916979m';         % row 6
%Name = '3919370m (1)';     % row 5
%Name = '3919370m';         % row 5
%Name = '3801060_0007m';    % row 1
Name = '3899985_0005m';    % row 1
%Name = 'a02m';             % row 1

load(strcat(Name, '.mat'));
fid = fopen(strcat(Name, '.info'), 'rt');
fgetl(fid);
fgetl(fid);
fgetl(fid);
[interval] = sscanf(fgetl(fid), 'Sampling frequency: %f Hz  Sampling interval: %f sec');
dt0 = interval(2);              % data acquisition rate (interval = 1/f_spl_u = 0.5903 ms in practice)

fclose(fid);

val(isnan(val)) = [];
t0 = (1:length(val)) * dt0;            % timeline
s0 = val(1,1:length(val));
s0  = (s0  - mean(s0 ))/sqrt(var(s0));        % rescale s on 0 (standard score of signal)

%   - Timeline, noise, integration, quantization -
dt = 1/20;                           % sampling time: dt >> dt0
t_int = dt * (1/3);                  % integration time: dt0 <= t_int < dt
quant = 0.1;                         % LSB: vertical step

[t,s] = integration(t0,s0,dt0,dt,t_int,quant,0);

[t0_, s0_, t_, s_] = time_div(t0,s0,dt0, t,s,dt,5,10);

%  - Peaks identification -
%[kx,tx,sx, dhi,dlo, td,d, kx_n,tx_N,sx_N, note_x] = signal_peaks(t_,s_);

d = s_(2:end) -  s_(1:end-1);
td = t_(2:end);
kx = d > 0;
kx = find(kx(1:end-1) & ~kx(2:end));       % k_{x}:index where d(k(x) > 0; d( k(x) + 1 ) <= 0

sx = s_(kx+1);                          % local maxima
tx = td(kx) + (td(kx+1)-td(kx)) .* d(kx)./(d(kx)-d(kx+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)

dhi = d(kx);
dlo = d(kx+1);

for k = 1:length(kx)
    i = kx(k)-1;   while i > 0             && d(i) >= dhi(k); dhi(k) = d(i); i = i-1; end    % search for maximum positive slope at kx-
    i = kx(k)+2;   while i < length(d) && d(i) <= dlo(k); dlo(k) = d(i); i = i+1; end    % search for maximmum negative slope at kx+
end

kx_n = d < 0;                               % search for local minima
kx_n = find(kx_n(1:end-1) & ~kx_n(2:end));

if kx_n(1) < kx(1)
    for k = 1:length(kx)
        kx_index(k) = max( find( kx_n < kx(k) ) );
    end
    sx_N = s_(kx_n( kx_index ) + 1);
    tx_N = td(kx_n( kx_index )) + (td(kx_n( kx_index )+1)-td(kx_n( kx_index ))) .* d(kx_n( kx_index ))./(d(kx_n( kx_index ))-d(kx_n( kx_index )+1));
else
    j = 1;
    while kx_n(1) > kx(j)                   % find first minima preceding maxima
        kx_index(j) = nan;
        sx_N(j) = nan;
        tx_N(j) = nan;
        j = j+1;
    end
    for k = j:length(kx)
        kx_index(k) = max( find( kx_n < kx(k) ) );
        sx_N(k) = s_(kx_n( kx_index(k) ) + 1);
        tx_N(k) = td(kx_n( kx_index(k) )) + (td(kx_n( kx_index(k) )+1)-td(kx_n( kx_index(k) ))) .* d(kx_n( kx_index(k) ))./(d(kx_n( kx_index(k) ))-d(kx_n( kx_index(k) )+1));
    end
    
end

%   - Peaks notation
sorted = sort(sx);
norm = sorted(floor(0.8*length(sx)));   % 8/10 rank in sorted sx array (avoid maxima artifact)

sorted_N = sort(sx_N);
norm_N = sorted_N(floor(0.2*length(sx_N)));

sx_norm = sx * (2.5/norm);                   % normalize amplitude
sx_N_norm = - abs( sx_N * (0.5/norm_N) );

note_1 = sx;
note_1_norm = sx_norm;

note_2 = dhi - dlo;                           % maximum slope difference around peak

for k = 1:length(tx)
    if tx(k) >= tx_N(k)
        delta(k) = sx(k) - sx_N(k);
        delta_norm(k) = sx_norm(k) - sx_N_norm(k);
    else                                     % if minimum out of frame, take first min in the frame
        j = k;
        while isnan(sx_N(j))
            j = j+1;
        end
        delta(k) = sx(k) - sx_N(j);
        delta_norm(k) = sx_norm(k) - sx_N_norm(j);
        clearvars j;
    end
end
note_3 = delta;
note_3_norm = delta_norm;

for k = 2:length(kx)-1
    note_1(k) = sx(k) - ( sx(k+1) + sx(k-1) )/2;
    note_1_norm(k) = sx_norm(k) - ( sx_norm(k+1) + sx_norm(k-1) )/2;            % average peak value
    
    note_3(k) = delta(k) - ( delta(k+1) + delta(k-1) )/2;
    note_3_norm(k) = delta_norm(k) - ( delta_norm(k+1) + delta_norm(k-1) )/2;                  % average peak to peak value
end

note_x = 0.1*note_1 + 0.1*note_2 + 0.8*delta;
note_x_norm = 0.1*note_1_norm + 0.1*note_2 + 0.8*delta_norm;


%   - Remove artifact peak -
sorted_note = sort(note_x);
note_threshold = sorted_note(floor(0.9*length(note_x)));

for k = 1:length(note_x)
    if note_x(k) > 3*note_threshold
        note_x(k) = min(note_x);
    end
end

sorted_note_norm = sort(note_x_norm);
note_threshold_norm = sorted_note(floor(0.9*length(note_x_norm)));

for k = 1:length(note_x_norm)
    if note_x_norm(k) > 3*note_threshold_norm
        note_x_norm(k) = min(note_x_norm);
    end
end

% plot(note_x,'xb','MarkerSize',15);
% hold on
% plot(note_x_norm,'xr','MarkerSize',15);
% hold off

%       -- Minimum variance algorithm --
% [kx_major,tx_major,sx_major, T] = min_variance(t_,s_, td,d, kx,tx,sx,note_x, 0.1);
eps = 0.1;
kx_ = kx;

%   - Clustering according to minimum variance of note_x -
for i = 1:length(kx)
    if kx_(i) ~= 0
        
        idx(1,i) = kx(i);
        per(1,i) = tx(i);
        note(1,i) = note_x(i);
        j = 2;
        
        for k = i + 1 : length(kx)
            
            if  var([note_x(i) note_x(k)],1) < eps;
                
                idx(j,i) = kx(k);
                per(j,i) = tx(k);
                note(j,i) = note_x(k);
                
                kx_(k) = 0;
                j = j+1;
            else
                idx(j,i)=nan;
                per(j,i)=nan;
                note(j,i)=nan;
                
                j = j+1;
            end
            
        end
    end
end

%   - Remove columns -
zero = find(~idx(1,:));

for k = 1:length(zero)
    idx(:,zero(k))=[];
    per(:,zero(k))=[];
    note(:,zero(k))=[];
    zero = bsxfun(@minus ,zero,ones(1,length(zero))) ;
end

%   - Create cells: kx-tx-note_x -
L = size(idx);
for k = 1:L(2)
    NAN_ = ~isnan(idx(:,k));         % extract non NAN value of idx, per, note
    NAN_idx = idx(NAN_,k);
    NAN_per = per(NAN_,k);
    NAN_note = note(NAN_,k);
    
    idx_ = NAN_idx(find(NAN_idx));     % extract non zero value of idx, per, note
    per_ = NAN_per(find(NAN_per));
    note_ = NAN_note(find(NAN_note));
    
    clust_cell{k,1} = idx_;            % kx
    clust_cell{k,2} = per_;            % tx
    clust_cell{k,3} = note_;           % note_x
    
    clear NAN_ NAN_idx NAN_per NAN_note idx_ per_ note_
end

%   - Cluster notation: size, tx periodicity, note_x -
for k = 1:L(2)
    if length(clust_cell{k,1}) > 2
        
        SIZE(k) = length(clust_cell{k,1});                                 % size
        [PER_T(k),PER_eps(k), PER_R(k)] = periodicity(clust_cell{k,2});    % tx periodicity
        
        if PER_eps(k) <= 0.1            % best periodicity note set to 0.1 otherwise increase too much the cluster note
            PER_eps(k) = 0.1;
        end
        
        NOTE(k) = mean(clust_cell{k,3});                                             % average note_x
        clust_note(k) = (0.7 * NOTE(k) + 0.2 * SIZE(k)) / (PER_eps(k)/0.1);          % cluster note EMPIRICAL
        
    else
        SIZE(k) = length(clust_cell{k,1});
        PER_T(k) = 0; PER_eps(k) = 0; PER_R(k) = 0;
        NOTE(k) = mean(clust_cell{k,3});
        clust_note(k) = 0;
        
    end
end

tbl_note = table([1:L(2)]', SIZE', PER_T',PER_eps', PER_R', NOTE', clust_note','VariableNames',{'Cluster','Size','T','eps','R','Note_x','Cluster_note'});

%   - Select major cluster + merge sub-major clusters -
Nrows = max(cellfun(@numel,clust_cell));
X = nan(Nrows(1),L(2));
for iCol = 1:L(2)
    X(1:numel(clust_cell{iCol}),iCol) = clust_cell{iCol};       % copy idx values of each cluster into X
end
clust_merge = nan(Nrows(1),L(2));

if L(2) >= 2                                             % more than 1 cluster
    if all(clust_note == 0)
        [NOTE_major major_idx] = max(NOTE);
        kx_major = clust_cell{major_idx,1}';
        
        NOTE_comp = NOTE_major;                    % EMP
        
        if all(NOTE <= 1)                % EMP
            for k = 1:L(2)
                if var([NOTE_major NOTE(k)],1) < 7*eps                                            % EMPIRICAL: compare NOTE to NOTE of major cluster
                    NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );
                    clust_merge(:,k) = X(:,k);                                                    % merge cluster to major cluster
                    NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );   % recompute NOTE_major
                    
                    NOTE_comp = NOTE_major;        % EMP
                end
            end
        else
            for k = 1:L(2)
                if var([NOTE_major NOTE(k)],1) < 7*eps && NOTE(k) > 1 %EMP                                % EMPIRICAL: compare NOTE to NOTE of major cluster
                    NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );
                    clust_merge(:,k) = X(:,k);                                                      % merge cluster to major cluster
                    NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );     % recompute NOTE_major
                    
                    NOTE_comp = NOTE_major;       % EMP
                end
            end
        end
    else
        if all(NOTE <= 1)               % EMP
            [NOTE_major major_idx] = max(NOTE);
            kx_major = clust_cell{major_idx,1}';
            
            NOTE_comp = NOTE_major;               % EMP
            
            for k = 1:L(2)
                if var([NOTE_major NOTE(k)],1) < 7*eps                                               % EMPIRICAL: compare NOTE to NOTE of major cluster
                    NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );
                    clust_merge(:,k) = X(:,k);                                                       % merge cluster to major cluster
                    NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );      % recompute NOTE_major
                    
                    NOTE_comp = NOTE_major;       % EMP
                end
            end
            
        else
            [clust_note_temp idx_temp] = max(clust_note);
            
            if NOTE(idx_temp)  > 1     % EMP
                major_idx = idx_temp;
                kx_major = clust_cell{major_idx,1}';
                clust_note_major = clust_note_temp;
                NOTE_major = NOTE(major_idx);
                
                NOTE_comp = NOTE_major;           % EMP
                
                for k = 1:L(2)
                    if clust_note(k) > 1 && var([NOTE_major NOTE(k)],1) < 7*eps && NOTE(k) > 1     % EMPIRICAL: compare NOTE to NOTE of major cluster
                        NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );
                        clust_merge(:,k) = X(:,k);                                                  % merge cluster to major cluster
                        NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) ); % recompute NOTE_major
                        
                        NOTE_comp = NOTE_major;           % EMP
                    elseif clust_note(k) == 0 && var([NOTE_major NOTE(k)],1) < 7*eps && NOTE(k) > 1
                        NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) ); % EMPIRICAL: compare NOTE to NOTE of major cluster (that have max clust_note)
                        clust_merge(:,k) = X(:,k);                                                  % merge cluster to major cluster
                        NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) ); % recompute NOTE_major
                        
                        NOTE_comp = NOTE_major;           % EMP
                    end
                end
                
            else
                [NOTE_major major_idx] = max(NOTE);
                kx_major = clust_cell{major_idx,1}';
                
                NOTE_comp = NOTE_major;           % EMP
                
                for k = 1:L(2)
                    if var([NOTE_major NOTE(k)],1) < 7*eps  && NOTE(k) > 1                             % EMPIRICAL: compare NOTE to NOTE of major cluster
                        NOTE_major = NOTE(k) * ( Nrows(1) - sum(isnan(X(:,k))) ) + NOTE_major * ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );
                        clust_merge(:,k) = X(:,k);                                                      % merge cluster to major cluster
                        NOTE_major = NOTE_major / ( L(2)*Nrows(1) - sum(sum(isnan(clust_merge))) );     % recompute NOTE_major
                        
                        NOTE_comp = NOTE_major;           % EMP
                    end
                end
            end
        end
    end
    
    clust_merge(isnan(clust_merge)) = [];         % remove NaN values
    clust_merge = unique(clust_merge);            % remove repeated elements ans sort array
    kx_major(1,1:length(clust_merge)) = clust_merge;
    
else                                                    % one cluster only
    major_idx = 1;
    kx_major = clust_cell{major_idx,1}';
    clust_note_major = clust_note;
    NOTE_major = NOTE;
end

if length(kx_major) >= 2
    
    %   - Major peaks -
    kx_major = unique(kx_major);
    tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
    sx_major = s_(kx_major+1);          % local maxima
    T = mean(delta_tx(tx_major));
    
    % - Remove some merged peaks -
    [kx_major,tx_major,sx_major,T] = remove_peaks(kx_major,tx_major,sx_major, T, kx,note_x);
    
    %   - Add peaks to major cluster considering peaks periodicity -
    % Periodic peaks in row
    tx_rect = delta_tx(tx);
    
    kx_major_ = nan(1,length(kx)+length(kx_major));
    kx_major_(1:length(kx_major)) = kx_major;        % length(kx_major) < length(kx)
    
    for k = 1:length(tx_rect)
        if abs( tx_rect(k) - T )/T < 0.5             % less than 50% relative error from T
            if abs( (note_x(k) - note_x(k+1))/note_x(k) ) < 0.5 && (  ~any(kx_major == kx(k)) || ~any(kx_major == kx(k+1)) )           % similar note_x and kx not present in kx_major
                kx_major_(length(kx_major)+k) = kx(k);
                kx_major_(length(kx_major)+k+1) = kx(k+1);
                
                %             elseif abs( tx_rect(k) - T )/T < 0.2  && (  ~any(kx_major == kx(k)) || ~any(kx_major == kx(k+1)) )
                %                 kx_major_(length(kx_major)+k) = kx(k);
                %                 kx_major_(length(kx_major)+k+1) = kx(k+1);
            end
        end
    end
    
    kx_major_(isnan(kx_major_))=[];
    kx_major = unique(kx_major_);
    
    tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
    sx_major = s_(kx_major+1);          % local maxima
    T = mean(delta_tx(tx_major));
    
    % Periodic peaks separated by minor peak
    tx_rect2 = delta_tx(tx,2);
    
    kx_major_ = nan(1,length(kx)+length(kx_major));
    kx_major_(1:length(kx_major)) = kx_major;        % length(kx_major) < length(kx)
    
    for k = 1:length(tx_rect2)
        if abs( tx_rect2(k) - T )/T < 0.5             % less than 50% relative error from T and avoid periodic minor peaks
            if abs( (note_x(k) - note_x(k+2)) /note_x(k)) < 0.5 && abs( note_x(k) - NOTE_major )/ NOTE_major < 0.2 && ( ~any(kx_major == kx(k)) || ~any(kx_major == kx(k+2)) )
                kx_major_(length(kx_major)+k) = kx(k);
                kx_major_(length(kx_major)+k+1) = kx(k+2);
            end
        end
    end
    
    kx_major_(isnan(kx_major_))=[];
    kx_major = unique(kx_major_);
    
    tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
    sx_major = s_(kx_major+1);          % local maxima
    T = mean(delta_tx(tx_major));
    
    %       - Search for missing peaks -
    % Miss peaks inside the frame
    loop = 0;       % two loops in case big hole
    
    while loop < 2
        tx_pos = delta_tx(tx_major);
        kx_add = nan(1,length(kx_major));       % for horizontal concatenation
        
        for k = 1:length(tx_pos)                % assume ONE missing/skipped peak
            if tx_pos(k) > T + T/3            % need enough large frame length to give weight to T
                left(k) = kx_major(k);
                right(k) = kx_major(k+1);
                kx_add_ = kx( kx(1,:) > left(k) & kx(1,:) < right(k));
                
                if length(kx_add_) == 1         % one peak present in the hole
                    tx_pos_temp_left = tx(kx==kx_add_) - tx_major(k);
                    tx_pos_temp_right = tx_major(k+1) - tx(kx==kx_add_);
                    if var([NOTE_major note_x(kx==kx_add_)],1) < 5*eps || note_x(kx==kx_add_) > NOTE_major || (abs (tx_pos_temp_left/T) < 0.1 && abs (tx_pos_temp_right/T) < 0.1 ) 
                        if tx_pos_temp_left > T - T/3 && tx_pos_temp_right > T - T/3
                        kx_add(k) = kx_add_;
                        end
                    else
                        tx_pos(k) = nan;            % to compute T not affected by missing tx_major
                        kx_add(k) = 0;
                    end
                    clearvars kx_add_ tx_pos_temp;
                    
                elseif length(kx_add_) >= 2     % more than one peak present in the hole
                    for i = 1:length(kx_add_)
                        kx_add_idx(i) = find(kx == kx_add_(i));
                        kx_add_note(i) = note_x(kx_add_idx(i));
                    end
                    
                    [value kx_add_max] = max(kx_add_note);
                    tx_pos_temp = tx(kx_add_idx(kx_add_max)) - tx_major(k);         % delta_tx from major peak to added peak
                    
                    if var([NOTE_major value],1) < 5*eps || value > NOTE_major || (abs (tx_pos_temp_left/T) < 0.1 && abs (tx_pos_temp_right/T) < 0.1 ) 
                        kx_add(k) = kx_add_(kx_add_max);        % max note_x index added to major cluster
                    else
                        tx_pos(k) = nan;            % to compute T not affected by missing tx_major
                        kx_add(k) = 0;
                    end
                    clearvars kx_add_ kx_add_idx kx_add_note kx_add_max value tx_pos_temp ;
                    
                else                            % no peak present in the hole => create peak
                    tx_pos(k) = nan;            % to compute T not affected by missing tx_major
                    kx_add(k) = 0;
                    
                end
            end
            
        end
        
        % Add/create peak to major cluster
        %[kx_major, tx_major, sx_major, T] = add_peaks(t_,s_,td,d, tx_pos,kx_major,tx_major,sx_major,kx_add);
        
        if find(kx_add==0)                      % imaginary peak to create & peak to add
    zeros = find(kx_add==0);            % indexes where create a peak
    tx_pos(isnan(tx_pos)) = [];         % remove nan values
    T_temp = mean(tx_pos);              % peaks period (not considering missing peak)
    
    insert = @(a, x, n)cat(2,  x(1:n), a, x(n+1:end));      % insert(element inserted,array,position)
    
    for k = 1:length(zeros)
        kx_major = insert(kx_major(zeros(k)), kx_major, zeros(k) );
        kx_add(zeros(k)) = nan;
        kx_add = insert(nan, kx_add, zeros(k));                             % for concatenation with kx_major
        
        zeros = bsxfun(@plus , zeros, ones(1,length(zeros)));               % shift index of zeros when adding one element in tx_major, sx_major
    end
    
    kx_major = horzcat(kx_major,kx_add);        % add peak to major cluster
    kx_major(isnan(kx_major)) = [];             % remove NaN values
    kx_major = sort(kx_major);                  % sort
    
    for k = 1:length(kx_major)-1                % peak to add
        if kx_major(k)~=kx_major(k+1)
            tx_major(k+1) = td(kx_major(k+1)) + (td(kx_major(k+1)+1)-td(kx_major(k+1))) .* d(kx_major(k+1))./(d(kx_major(k+1))-d(kx_major(k+1)+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
        else                                    % peak to create
            tx_major(k+1) = tx_major(k) + T_temp;
        end
        sx_major(k+1) = s_(kx_major(k+1)+1);        % local maxima
    end
else                                            % peak to add only
    kx_major = horzcat(kx_major,kx_add);        % add peak to major cluster
    kx_major(isnan(kx_major)) = [];             % remove NaN values
    kx_major = unique(kx_major);                % sort
    
    tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
    sx_major = s_(kx_major+1);                  % local maxima
    
end

T = mean(delta_tx(tx_major));
        
        clearvars tx_pos kx_add;
        loop = loop+1;
    end
    
    % Miss first peak
    insert = @(a, x, n)cat(2,  x(1:n), a, x(n+1:end));      % insert(element inserted,array,position)
    
    if abs( tx(1) - tx_major(1) ) > T + T/5
        kx_major = insert(kx(1),kx_major,0);
        tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
        sx_major = insert(sx_major(1),sx_major,0);                                                                % for visibility
        T = mean(delta_tx(tx_major));
    end
    
    % Miss last peak
    if abs( tx(end) - tx_major(end) ) > T + T/5
        kx_major = insert(kx(end),kx_major,length(kx_major));
        tx_major = td(kx_major) + (td(kx_major+1)-td(kx_major)) .* d(kx_major)./(d(kx_major)-d(kx_major+1));      % linear interpolation of dhi and dho to get tx (@zero crossing)
        sx_major = insert(sx_major(end),sx_major,length(sx_major));                                               % for visibility
        T = mean(delta_tx(tx_major));
    end
    
    %   - Remove peaks from major cluster -
    [kx_major,tx_major,sx_major,T] = remove_peaks(kx_major,tx_major,sx_major, T, kx, note_x);
    
else
    display('Not enough points');
    tx_major = nan;
    sx_major = nan;
    T = nan;
    
end

%%
%   - Plots -
figure(2);
plot( tx , sx   , 'dc','MarkerSize',12);
hold on
plot(t_,s_,'ok','LineWidth',.2);
plot(t0_,s0_,'-k');
plot(tx, dhi,'^b','MarkerSize',10);
plot(tx, dlo,'vb','MarkerSize',10);
plot( kron(tx,[1 1 1]) , kron(dlo,[1 0 nan]) + kron(dhi,[0 1 nan]), '-b');       % link note_2
plot( tx_major , sx_major, 'pr','MarkerSize',20);
plot( tx,sx_N, 'dc','MarkerSize',10);
plot(kron(tx,[1 1 1]), kron(sx_N,[1 0 nan]) + kron(sx,[0 1 nan]),'-c');
hold off
